<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>World Generation</title>
        <link rel="stylesheet" href="../css/default.css" />
	<!-- LaTeX render options -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
	<!-- math jax -->
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<!-- tikz jax -->
	<link rel="stylesheet" type="text/css" href="http://tikzjax.com/v1/fonts.css">
	<script src="https://tikzjax.com/v1/tikzjax.js"></script>

    </head>
    <body>
        <header>
	  <nav>
	    <a class="home" href="../index.html">Home</a> 
	    <a href="../papers.html">Papers</a> 
	    <a href="../cv.html">CV</a> 
	    <a href="../writing.html">Writing</a>
	    <a href="../quotes.html">Quotes</a> 
	  </nav>
        </header>

        <main role="main">
          <h1>World Generation</h1>
	  <div class="pdf">
	  
	  
	  </div>
	  <div class="content-body">
	    <p>Different types of world generation</p>
<h1 id="continuous-random-noise-map">Continuous Random Noise Map</h1>
<p>If we can make a continuous noise map, then we can generate a map based on those values.
For example, we can build a simple infinite dungeon by generating a path anywhere, where the value is in the range (0.3, 0.7) or (0.4, 0.6).</p>
<p><img src="../images/WorldGeneration/Screenshot from 2021-03-18 03-09-06.png" style="display: block; margin-left: auto; margin-right: auto;" width="500" /></p>
<p><img src="../images/WorldGeneration/Screenshot from 2021-03-18 03-15-10.png" style="display: block; margin-left: auto; margin-right: auto;" width="500" /></p>
<p>You can also different layers to represent e.g. height (0.01), humidity (0.02) and temperature (0.04).</p>
<p><img src="../images/WorldGeneration/map_image_noise_height.png" style="display: block; margin-left: auto; margin-right: auto;" width="500" /></p>
<p><img src="../images/WorldGeneration/map_image_noise_humidity.png" style="display: block; margin-left: auto; margin-right: auto;" width="500" /></p>
<p><img src="../images/WorldGeneration/map_image_noise_temperature.png" style="display: block; margin-left: auto; margin-right: auto;" width="500" /></p>
<p>By having different scales, we get a dynamic interaction, and slow but consistent change in biomes. Overlaying these we get:</p>
<p><img src="../images/WorldGeneration/map_image_noise_biome.png" style="display: block; margin-left: auto; margin-right: auto;" width="500" /></p>
<p>File: <code>noise_layer.py</code> – Commit: <code>69a6bdf</code> of <code>ILL-Release</code>.</p>
<h2 id="system-random-noise">System Random Noise</h2>
<p>TODO: Describe why we are not using system random noise</p>
<h2 id="perlin-noise">Perlin Noise</h2>
<p>TODO: Describe why we are not using Perlin noise</p>
<h2 id="simplex-noise">Simplex Noise</h2>
<p>TODO: Describe why we are not using simplex noise</p>
<h2 id="opensimplex-noise">OpenSimplex Noise</h2>
<p>TODO: Describe why we are using OpenSimplex noise</p>
<h1 id="chunk-loading">Chunk loading</h1>
<p>Whenever we get close to a new chunk, we check whether we have generated it already, by checking if the file <code>&lt;prefix&gt;_&lt;x&gt;_&lt;y&gt;.ill</code> exists.
If it does not, then we run the generation script for that given chunk based on our current distance to the chunk.
Given that we want to load <span class="math inline"><em>r</em></span> chunks around us, and the generation has <span class="math inline"><em>n</em></span> levels then we must load everything at distance <span class="math inline"><em>d</em></span> to level
<span class="math display">(<em>r</em>+<em>n</em>) − <em>d</em></span>
with a maximum of <span class="math inline"><em>n</em></span> and a minimum of <span class="math inline">0</span>.
This ensures that we are not loading too much at a time, and allows us to make very consistent world gen across chunk boundaries,
as any level can depend on all previous levels within a radius of a chunk.
This method also allows us to make road networks and other global structure, if we have a high enough level of generation.</p>
<h1 id="infinite-world-generation">Infinite world generation</h1>
<p>Infinite worlds builds on the mechaninc described in the chunk loading and noise maps.
This allows us to generate a continuous random looking world, but with consistent global structures.
We could even generate full questlines this way, without it looking weird or being inconsistent, but this would require us loading alot of chunks.</p>
<p>We could instead generate predefined points of interest, and then whenever we load one, we just need to connect to the surounding ones.
This can be done by running Astar, loading any chunk we need to walk through to a low level.
That is we can do this process recursively in different scales, not just around the player, but also for global structure.</p>
<h1 id="dungeon-generation">Dungeon generation</h1>
<p>We start by generating random points, then make a minimum spanning tree (allowing wrapping).
We can then normalize the map, so there is no wrapping.</p>
<p>We can do as we did with the noise maps.</p>
	  </div>
        </main>
	
        <footer>
	    Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
